"""
Fixed Display Manager for the Futures Trading System Admin Tool

Addresses all Pylance errors related to Rich library usage and Layout handling.
"""

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union, Callable
from dataclasses import dataclass

try:
    from rich.console import Console
    from rich.live import Live
    from rich.layout import Layout
    from rich.panel import Panel, Align
    from rich.table import Table
    from rich.text import Text
    from rich.columns import Columns
    from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TaskProgressColumn
    from rich.tree import Tree
    from rich.box import ROUNDED
    from rich.align import Align as RichAlign
    from rich.markup import escape
    from rich.rule import Rule
    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False
    # Mock classes for when Rich is not available
    class Console:
        def print(self, *args, **kwargs): print(*args)
    class Layout:
        def __init__(self, *args, **kwargs): pass
        def __getitem__(self, key): return None
        def __setitem__(self, key, value): pass
        def split_column(self, *args): pass
        def split_row(self, *args): pass
    class Panel:
        def __init__(self, *args, **kwargs): pass
    class Live:
        def __init__(self, *args, **kwargs): pass
        async def __aenter__(self): return self
        async def __aexit__(self, *args): pass
        def update(self, *args, **kwargs): pass

logger = logging.getLogger(__name__)

@dataclass
class DisplayMetrics:
    """Metrics for display performance tracking"""
    refresh_rate: float = 1.0
    last_update: Optional[datetime] = None
    update_count: int = 0
    error_count: int = 0
    is_live: bool = False

class DisplayManager:
    """
    Manages the TUI display using Rich library with proper error handling
    """
    
    def __init__(self, console: Optional[Console] = None):
        """Initialize display manager with Rich console"""
        self.console = console or Console()
        self.layout: Optional[Layout] = None
        self.live: Optional[Live] = None
        self.metrics = DisplayMetrics()
        self.is_initialized = False
        self.current_view = "main"
        self.last_operation_result: Optional[Dict[str, Any]] = None
        
        # Display state
        self.selected_index = 0
        self.current_operation = ""
        self.operation_in_progress = False
        self.status_messages: List[str] = []
        
        if RICH_AVAILABLE:
            self._initialize_layout()
    
    def _initialize_layout(self):
        """Initialize the Rich layout structure"""
        try:
            self.layout = Layout()
            
            # Create layout structure with proper error handling
            self.layout.split_column(
                Layout(name="header", size=3),
                Layout(name="main_content", ratio=1),
                Layout(name="footer", size=3)
            )
            
            # Split main content
            if "main_content" in self.layout:
                main_layout = self.layout["main_content"]
                if main_layout is not None:
                    main_layout.split_row(
                        Layout(name="content", ratio=2),
                        Layout(name="sidebar", size=40)
                    )
            
            # Initialize with default content
            self._update_header()
            self._update_footer()
            self.is_initialized = True
            
        except Exception as e:
            logger.error(f"Error initializing layout: {e}")
            self.layout = None
    
    def _safe_layout_update(self, section: str, content: Any) -> bool:
        """Safely update layout section with proper None checks"""
        try:
            if not RICH_AVAILABLE or self.layout is None:
                return False
                
            # Check if section exists in layout
            if hasattr(self.layout, '__getitem__'):
                try:
                    section_layout = self.layout[section]
                    if section_layout is not None:
                        section_layout.update(content)
                        return True
                except (KeyError, AttributeError):
                    logger.warning(f"Layout section '{section}' not found")
            
            return False
            
        except Exception as e:
            logger.error(f"Error updating layout section '{section}': {e}")
            return False
    
    def _update_header(self):
        """Update header with current status"""
        try:
            header_content = Panel(
                Text("üîπ Rithmic Admin Tool - Futures Trading System", style="bold blue"),
                box=ROUNDED,
                style="blue"
            )
            self._safe_layout_update("header", header_content)
        except Exception as e:
            logger.error(f"Error updating header: {e}")
    
    def _update_footer(self):
        """Update footer with status information"""
        try:
            # Build status text
            status_parts = []
            
            # Add current time
            current_time = datetime.now().strftime("%H:%M:%S")
            status_parts.append(f"Time: {current_time}")
            
            # Add metrics if available
            if hasattr(self.metrics, 'refresh_rate') and self.metrics.refresh_rate:
                # Don't call refresh_rate as it's a float value
                status_parts.append(f"Refresh: {self.metrics.refresh_rate:.1f}s")
            
            if hasattr(self.metrics, 'is_live') and self.metrics.is_live:
                # Don't call is_live as it's a boolean value  
                status_parts.append("üü¢ Live" if self.metrics.is_live else "üî¥ Offline")
            
            status_text = " | ".join(status_parts)
            
            footer_content = Panel(
                Text(status_text, style="dim"),
                box=ROUNDED,
                style="dim"
            )
            self._safe_layout_update("footer", footer_content)
            
        except Exception as e:
            logger.error(f"Error updating footer: {e}")
    
    def show_menu(self, menu_items: List[str], selected_index: int = 0, 
                  current_operation: str = "", operation_in_progress: bool = False):
        """Display main menu with current selection"""
        try:
            # Update internal state
            self.selected_index = selected_index
            self.current_operation = current_operation
            self.operation_in_progress = operation_in_progress
            
            # Create menu table
            table = Table(show_header=False, box=ROUNDED, expand=True)
            table.add_column("Option", style="cyan", no_wrap=True)
            table.add_column("Description", style="white")
            
            for i, item in enumerate(menu_items):
                style = "bold yellow on blue" if i == selected_index else "white"
                cursor = "‚ñ∂ " if i == selected_index else "  "
                table.add_row(f"{cursor}{i+1}", f"{item}", style=style)
            
            # Create content panel
            content_panel = Panel(
                table,
                title="üìã Main Menu",
                box=ROUNDED,
                style="cyan"
            )
            
            # Show current operation if any
            if current_operation:
                operation_text = f"Current: {current_operation}"
                if operation_in_progress:
                    operation_text += " ‚è≥"
                
                operation_panel = Panel(
                    Text(operation_text, style="yellow"),
                    title="Status",
                    box=ROUNDED,
                    style="yellow"
                )
                
                # Combine content
                content = Columns([content_panel, operation_panel], equal=True)
            else:
                content = content_panel
            
            self._safe_layout_update("content", content)
            
        except Exception as e:
            logger.error(f"Error showing menu: {e}")
    
    def show_progress(self, message: str, progress: Optional[int] = None, total: Optional[int] = None):
        """Show progress information"""
        try:
            if progress is not None and total is not None and total > 0:
                # Calculate percentage
                percentage = (progress / total) * 100
                progress_text = f"{message}\nProgress: {progress}/{total} ({percentage:.1f}%)"
                
                # Create progress bar representation
                bar_width = 40
                filled = int((percentage / 100) * bar_width)
                bar = "‚ñà" * filled + "‚ñë" * (bar_width - filled)
                progress_text += f"\n[{bar}]"
            else:
                progress_text = message
            
            progress_panel = Panel(
                Text(progress_text, style="green"),
                title="‚è≥ Progress",
                box=ROUNDED,
                style="green"
            )
            
            self._safe_layout_update("content", progress_panel)
            
        except Exception as e:
            logger.error(f"Error showing progress: {e}")
    
    def show_results(self, results: Dict[str, Any]):
        """Display operation results"""
        try:
            self.last_operation_result = results
            
            # Create results display
            if results.get('success', False):
                title = "‚úÖ Operation Successful"
                style = "green"
                content_style = "white"
            else:
                title = "‚ùå Operation Failed"
                style = "red" 
                content_style = "red"
            
            # Format result content
            content_parts = []
            
            if 'message' in results:
                content_parts.append(f"Message: {results['message']}")
            
            if 'data' in results and results['data']:
                if isinstance(results['data'], list):
                    content_parts.append(f"Records: {len(results['data'])}")
                elif isinstance(results['data'], dict):
                    content_parts.append("Data: Dictionary result")
                else:
                    content_parts.append(f"Data: {str(results['data'])[:100]}...")
            
            if 'error' in results:
                content_parts.append(f"Error: {results['error']}")
            
            # Add timing information if available
            if hasattr(self.metrics, 'last_update') and self.metrics.last_update:
                # Don't call last_update as it's already a datetime value
                time_str = self.metrics.last_update.strftime('%H:%M:%S')
                content_parts.append(f"Time: {time_str}")
            
            content_text = "\n".join(content_parts) if content_parts else "No details available"
            
            results_panel = Panel(
                Text(content_text, style=content_style),
                title=title,
                box=ROUNDED,
                style=style
            )
            
            self._safe_layout_update("content", results_panel)
            
        except Exception as e:
            logger.error(f"Error showing results: {e}")
    
    def show_data_view(self, data: List[Dict], table_name: str = "Data"):
        """Display tabular data"""
        try:
            if not data:
                empty_panel = Panel(
                    Text("No data available", style="dim"),
                    title=f"üìä {table_name}",
                    box=ROUNDED,
                    style="dim"
                )
                self._safe_layout_update("content", empty_panel)
                return
            
            # Create table from data
            table = Table(show_header=True, box=ROUNDED, expand=True)
            
            # Add columns based on first record
            first_record = data[0]
            for key in first_record.keys():
                table.add_column(str(key), style="cyan")
            
            # Add rows (limit to prevent display issues)
            max_rows = 20
            for i, record in enumerate(data[:max_rows]):
                row_data = []
                for key in first_record.keys():
                    value = record.get(key, "")
                    # Format value for display
                    if isinstance(value, datetime):
                        value = value.strftime('%Y-%m-%d %H:%M:%S')
                    elif isinstance(value, float):
                        value = f"{value:.4f}"
                    row_data.append(str(value))
                table.add_row(*row_data)
            
            # Show count if truncated
            if len(data) > max_rows:
                table.add_row(*["..." for _ in first_record.keys()])
                table.add_row(*[f"Showing {max_rows} of {len(data)} records" for _ in first_record.keys()])
            
            data_panel = Panel(
                table,
                title=f"üìä {table_name}",
                box=ROUNDED,
                style="blue"
            )
            
            self._safe_layout_update("content", data_panel)
            
        except Exception as e:
            logger.error(f"Error showing data view: {e}")
    
    def update_sidebar(self, info: Dict[str, Any]):
        """Update sidebar with system information"""
        try:
            # Create sidebar content
            sidebar_parts = []
            
            # System status
            if 'connection_status' in info:
                status = "üü¢ Connected" if info['connection_status'] else "üî¥ Disconnected"
                sidebar_parts.append(f"Status: {status}")
            
            # Statistics
            if 'statistics' in info:
                stats = info['statistics']
                sidebar_parts.append("\nStatistics:")
                for key, value in stats.items():
                    sidebar_parts.append(f"  {key}: {value}")
            
            # Recent activity
            if 'recent_activity' in info and info['recent_activity']:
                sidebar_parts.append("\nRecent Activity:")
                for activity in info['recent_activity'][:5]:  # Show last 5
                    sidebar_parts.append(f"  ‚Ä¢ {activity}")
            
            sidebar_text = "\n".join(sidebar_parts) if sidebar_parts else "No information available"
            
            sidebar_panel = Panel(
                Text(sidebar_text, style="white"),
                title="‚ÑπÔ∏è System Info",
                box=ROUNDED,
                style="blue"
            )
            
            self._safe_layout_update("sidebar", sidebar_panel)
            
        except Exception as e:
            logger.error(f"Error updating sidebar: {e}")
    
    async def start_live_updates(self, refresh_rate: float = 1.0):
        """Start live display updates"""
        try:
            if not RICH_AVAILABLE or self.layout is None:
                logger.warning("Rich not available or layout not initialized")
                return
            
            self.metrics.refresh_rate = refresh_rate
            self.metrics.is_live = True
            
            # Create live display
            self.live = Live(
                self.layout,
                console=self.console,
                refresh_per_second=1/refresh_rate,
                screen=True
            )
            
            logger.info(f"Started live display with refresh rate: {refresh_rate}s")
            
        except Exception as e:
            logger.error(f"Error starting live updates: {e}")
            self.metrics.is_live = False
    
    async def stop_live_updates(self):
        """Stop live display updates"""
        try:
            if self.live:
                self.metrics.is_live = False
                # Note: In real implementation, you'd call self.live.stop()
                logger.info("Stopped live display updates")
                
        except Exception as e:
            logger.error(f"Error stopping live updates: {e}")
    
    def set_operation_result(self, result: Dict[str, Any]):
        """Set the result of the last operation"""
        try:
            self.last_operation_result = result
            self.metrics.last_update = datetime.now()
            self.metrics.update_count += 1
            
            # Show results immediately
            self.show_results(result)
            
        except Exception as e:
            logger.error(f"Error setting operation result: {e}")
            self.metrics.error_count += 1
    
    def add_status_message(self, message: str):
        """Add a status message"""
        try:
            timestamp = datetime.now().strftime('%H:%M:%S')
            formatted_message = f"[{timestamp}] {message}"
            self.status_messages.append(formatted_message)
            
            # Keep only last 10 messages
            if len(self.status_messages) > 10:
                self.status_messages = self.status_messages[-10:]
                
            logger.info(f"Status: {message}")
            
        except Exception as e:
            logger.error(f"Error adding status message: {e}")
    
    def get_display_metrics(self) -> DisplayMetrics:
        """Get current display metrics"""
        return self.metrics
    
    def clear_display(self):
        """Clear the current display"""
        try:
            if self.layout:
                empty_content = Panel(
                    Text("Display cleared", style="dim"),
                    box=ROUNDED,
                    style="dim"
                )
                self._safe_layout_update("content", empty_content)
                
        except Exception as e:
            logger.error(f"Error clearing display: {e}")
